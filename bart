#!/usr/bin/env bash

# bart: the Bash-based Application Rapid Tester.
# a simple test harness for command line apps

set -u # defensive coding

set -e # error out if fixture code has syntax errors.
if [ -e 'bart_fixture.sh' ]; then
  source bart_fixture.sh
else
    function setup()
    {
      #cannot have an empty function, so putting a safe command
      echo "setup"
    }
    
    function teardown()
    {
      #cannot have an empty function, so putting a safe command
      echo "teardown"
    }
fi

set +e # turn error checking off so test runs' returns can be read

function main()
{
		if [[ $# -ne 2 ]]; then
			echo "Usage: bart command inputfile"
      exit 1
		fi
    local executable=$1
    local inputfile=$2

		if [ ! -e "$inputfile" ]; then
			echo $inputfile not found. exiting
      exit 1
		fi

    bart_banner

    #newline code from http://gslsrc.net/l007_loops_in_bash.html & http://superuser.com/questions/284187/bash-iterating-over-lines-in-a-variable
    orig_IFS="$IFS"
    IFS=$'\n'
    
		for inp in `cat $inputfile`; do
			setup
			
			OUTCOME=
      cmd="$executable $inp"
      echo Running: $cmd
			eval $cmd
      ret=$?
      
      check_for_expected $cmd
      if [[ ! $OUTCOME ]]; then
        ask_and_add_result $cmd $ret
      fi
			#echo outcome:$OUTCOME
			# outcome is set by either check_for_expected or ask_and_add_result
			print_outcome $cmd $ret $OUTCOME
      store_for_summary $executable $ret $OUTCOME
			
			teardown
    done
    IFS=$orig_IFS
    
    print_summary $executable
    bart_credits
}

function bart_banner()
{
	echo -e "\033[1;31mba\033[1;32mrt\033[0m started." 
}

function bart_credits()
{
	echo -e "\033[1;31mba\033[1;32mrt\033[0m done." 
}

BART_TEST_LOGFILE="./bart_test_log.tsv"

function check_for_expected()
{
  local cmd=$1

  EXPECTED_RET=

  if [ ! -e $BART_TEST_LOGFILE ]; then
    touch $BART_TEST_LOGFILE
  fi
  # find previous result
  prev=`grep $cmd $BART_TEST_LOGFILE`
  #echo previous result line: $prev
  if [[ ! $prev ]]; then
    return
  fi
  
  EXPECTED_RET=`echo "$prev" | cut -f2`
  #echo expected result: ${EXPECTED_RET}
  if [[ $EXPECTED_RET -eq $ret ]]; then
  	OUTCOME=PASSED
  else
  	OUTCOME=FAILED
  fi
}

function ask_and_add_result()
{
	local cmd=$1
  local ret=$2

	if [[ $ret -eq 127 ]]; then
		echo "Ran command: \"$cmd\", which failed. Do you want to continue with the next run(c) or quit(q)?"
	  read ans_proceed	# add -n1 to make it an instant response
	  if [ $ans_proceed != "c" -o $ans_proceed != "C" ]; then
			exit 3	# TODO: fix this to skip this iteration, not the whole process.
		fi
	fi
	echo
  echo "Ran command: \"$cmd\", which returned: $ret. Is this the expected result (y/n)?"
  read answer	# add -n1 to make it an instant response
  if [ $answer == "y" -o $answer == "Y" ]; then
		#careful with the line below. There's supposed to be a tab between the command and the return value. Some editors convert tabs to spaces.
    echo "$cmd	$ret" >> $BART_TEST_LOGFILE
		OUTCOME=PASSED
		return
  fi
	OUTCOME=FAILED
}

#global arrays used to hold results for summary display
EXECUTIONS=(  )
RETURNVALUES=(  )
OUTCOMES=(  )

function print_outcome()
{
    local cmd="$1"
		local ret=$2
    local outcome=$3

		case $outcome in
			PASSED )
				outcome_str="\033[0;32mPASSED\033[0m"
				;;
			FAILED )
				outcome_str="\033[0;31mFAILED\033[0m"
				;;
		esac
    echo -e "execution of: \"$cmd\" returned: $ret and outcome: $outcome_str"
}

function store_for_summary()
{
  EXECUTIONS[${#EXECUTIONS[@]}]=$1
  RETURNVALUES[${#RETURNVALUES[@]}]="$2"
  OUTCOMES[${#OUTCOMES[@]}]="$3"

}

function print_summary()
{
	local executable=$1
	
	echo
	echo -e "\033[1;31mba\033[1;32mrt\033[0m summary for runs of \"$executable\" :"
  count=${#EXECUTIONS[@]}
  i=0
  while [ $i -lt $count ]
  do
      print_outcome ${EXECUTIONS[$i]} ${RETURNVALUES[$i]} ${OUTCOMES[$i]}
      let "i = $i + 1"
  done
}
main $*
