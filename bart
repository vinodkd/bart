#! /usr/bin/env bash
# bart

SUT= 					# the system under test.
TEST_DATA_SOURCE= 		# the source of test data

BART_FIXTURE_FILE='bart_fixture.sh'
BART_TEST_DATA_FILE='bart_inputs'
BART_TEST_LOGFILE="./bart_test_log.tsv"

declare -a TEST_DATA=()

function main(){
	validate_env
	validate_args $*
	setup_fixture	# this could also setup test data
	set_testdata_from_source $TEST_DATA_SOURCE	#...which can be overridden here.
	execute_tests
	report_results
}

function validate_env(){
	# we could get smarty pants about finding where bart resides, but it seems easier to just setup a var.
	if [[ $BART_HOME == "" ]]; then
		echo "Please set \$BART_HOME to bart's install location and rerun."
		exit -1
	fi
}

function validate_args(){
	case $# in
		0 )
			echo "bart: the bash application rapid tester."
			echo "Usage: bart command [test_data]"
			echo "if test_inputs.file is omitted, you have two options:"
			echo "  1. the current dir must have a bart_test_data.txt file with inputs (one execution's args per line)"
			echo "  2. bart_fixture.sh must have a getinputs() defined."
			exit -2
			;;
		1 )
			SUT=$1
			TEST_DATA_SOURCE=$BART_TEST_DATA_FILE	# use the default
			;;
		2 )
			SUT=$1
			TEST_DATA_SOURCE=$2
			;;
		* )
			SUT=$1
			TEST_DATA_SOURCE=$2
			;;
	esac
}

function setup_fixture(){
	if [[ -e $BART_FIXTURE_FILE ]]; then
		echo "reading local fixture file"
		source ./$BART_FIXTURE_FILE
	else
		echo "reading default fixture file"
		source $BART_HOME/$BART_FIXTURE_FILE
	fi
	set_testdata
	echo "Loaded ${#TEST_DATA[*]} rows of test data"
}

function set_testdata_from_source(){
	local testdata_source=$1
	local i=0
	while read line; do
		if [[ -n "$line" ]]; then
			TEST_DATA[$i]="$line"
			let "i = $i + 1"
		fi
	done < $testdata_source
}

function execute_tests(){
	echo Size is: ${#TEST_DATA[*]}
	bart_banner
	for inp in "${TEST_DATA[@]}"; do
		setup
		
		OUTCOME=
    	cmd="$SUT $inp"
    	echo Running: "$cmd"
		eval "$cmd"
		ret=$?

		check_for_expected "$cmd"
		if [[ ! $OUTCOME ]]; then
			ask_and_add_result "$cmd" $ret
		fi
		#echo outcome:$OUTCOME
		# outcome is set by either check_for_expected or ask_and_add_result
		print_outcome "$cmd" $ret $OUTCOME
		store_for_summary "$SUT" $ret $OUTCOME

    	teardown
    done
}

function report_results(){
  print_summary $SUT
  bart_credits
}

function bart_banner()
{
	echo -e "\033[1;31mba\033[1;32mrt\033[0m started." 
}

function bart_credits()
{
	echo -e "\033[1;31mba\033[1;32mrt\033[0m done." 
}


function check_for_expected()
{
	local cmd="$1"
	echo cfe:$cmd

	EXPECTED_RET=

	if [ ! -e $BART_TEST_LOGFILE ]; then
		touch $BART_TEST_LOGFILE
	fi
	# find previous result
	prev=$( grep "$cmd" $BART_TEST_LOGFILE )
	echo previous result line: $prev
	if [[ ! $prev ]]; then
		return
	fi

	EXPECTED_RET=`echo "$prev" | cut -f2`
	#echo expected result: ${EXPECTED_RET}
	if [[ $EXPECTED_RET -eq $ret ]]; then
		OUTCOME=PASSED
	else
		OUTCOME=FAILED
	fi
}

function ask_and_add_result()
{
	local cmd=$1
	local ret=$2

	if [[ $ret -eq 127 ]]; then
		echo "Ran command: \"$cmd\", which failed. Do you want to continue with the next run(c) or quit(q)?"
	 	read ans_proceed	# add -n1 to make it an instant response
		if [ $ans_proceed != "c" -o $ans_proceed != "C" ]; then
			exit 3	# TODO: fix this to skip this iteration, not the whole process.
		fi
	fi
	echo
	echo "Ran command: \"$cmd\", which returned: $ret. Is this the expected result (y/n)?"
	read answer	# add -n1 to make it an instant response
	if [ $answer == "y" -o $answer == "Y" ]; then
		#careful with the line below. There's supposed to be a tab between the command and the return value. Some editors convert tabs to spaces.
		echo "$cmd	$ret" >> $BART_TEST_LOGFILE
		OUTCOME=PASSED
		return
	fi
	OUTCOME=FAILED
}

#global arrays used to hold results for summary display
EXECUTIONS=(  )
RETURNVALUES=(  )
OUTCOMES=(  )

function print_outcome()
{
	local cmd="$1"
	local ret=$2
	local outcome=$3

	case $outcome in
		PASSED )
			outcome_str="\033[0;32mPASSED\033[0m"
			;;
		FAILED )
			outcome_str="\033[0;31mFAILED\033[0m"
			;;
	esac
	echo -e "execution of: \"$cmd\" returned: $ret and outcome: $outcome_str"
}

function store_for_summary()
{
  EXECUTIONS[${#EXECUTIONS[@]}]="$1"
  RETURNVALUES[${#RETURNVALUES[@]}]="$2"
  OUTCOMES[${#OUTCOMES[@]}]="$3"
}

function print_summary()
{
	local executable=$1

	echo
	echo -e "\033[1;31mba\033[1;32mrt\033[0m summary for runs of \"$executable\" :"
	count=${#EXECUTIONS[@]}
	i=0
	while [ $i -lt $count ]
	do
		print_outcome ${EXECUTIONS[$i]} ${RETURNVALUES[$i]} ${OUTCOMES[$i]}
		let "i = $i + 1"
	done
}

main $*